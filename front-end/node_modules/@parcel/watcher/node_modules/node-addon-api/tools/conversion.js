#! /usr/bin/env node

'use strict';

const fs = require('fs');
const path = require('path');

const args = process.argv.slice(2);
const dir = args[0];
if (!dir) {
  console.log('Usage: node ' + path.basename(__filename) + ' <target-dir>');
  process.exit(1);
}

const NodeApiVersion = require('../package.json').version;

const disable = args[1];
let ConfigFileOperations;
if (disable !== '--disable' && dir !== '--disable') {
  ConfigFileOperations = {
    'package.json': [
      [/([ ]*)"dependencies": {/g, '$1"dependencies": {\n$1  "node-addon-api": "' + NodeApiVersion + '",'],
      [/[ ]*"nan": *"[^"]+"(,|)[\n\r]/g, '']
    ],
    'binding.gyp': [
      [/([ ]*)'include_dirs': \[/g, '$1\'include_dirs\': [\n$1  \'<!(node -p "require(\\\'node-addon-api\\\').include_dir")\','],
      [/([ ]*)"include_dirs": \[/g, '$1"include_dirs": [\n$1  "<!(node -p \\"require(\'node-addon-api\').include_dir\\")",'],
      [/[ ]*("|')<!\(node -e ("|'|\\"|\\')require\(("|'|\\"|\\')nan("|'|\\"|\\')\)("|'|\\"|\\')\)("|')(,|)[\r\n]/g, ''],
      [/([ ]*)("|')target_name("|'): ("|')(.+?)("|'),/g, '$1$2target_name$2: $4$5$6,\n      $2cflags!$2: [ $2-fno-exceptions$2 ],\n      $2cflags_cc!$2: [ $2-fno-exceptions$2 ],\n      $2xcode_settings$2: { $2GCC_ENABLE_CPP_EXCEPTIONS$2: $2YES$2,\n        $2CLANG_CXX_LIBRARY$2: $2libc++$2,\n        $2MACOSX_DEPLOYMENT_TARGET$2: $210.7$2,\n      },\n      $2msvs_settings$2: {\n        $2VCCLCompilerTool$2: { $2ExceptionHandling$2: 1 },\n      },']
    ]
  };
} else {
  ConfigFileOperations = {
    'package.json': [
      [/([ ]*)"dependencies": {/g, '$1"dependencies": {\n$1  "node-addon-api": "' + NodeApiVersion + '",'],
      [/[ ]*"nan": *"[^"]+"(,|)[\n\r]/g, '']
    ],
    'binding.gyp': [
      [/([ ]*)'include_dirs': \[/g, '$1\'include_dirs\': [\n$1  \'<!(node -p "require(\\\'node-addon-api\\\').include_dir")\','],
      [/([ ]*)"include_dirs": \[/g, '$1"include_dirs": [\n$1  "<!(node -p \'require(\\"node-addon-api\\").include_dir\')",'],
      [/[ ]*("|')<!\(node -e ("|'|\\"|\\')require\(("|'|\\"|\\')nan("|'|\\"|\\')\)("|'|\\"|\\')\)("|')(,|)[\r\n]/g, ''],
      [/([ ]*)("|')target_name("|'): ("|')(.+?)("|'),/g, '$1$2target_name$2: $4$5$6,\n      $2cflags!$2: [ $2-fno-exceptions$2 ],\n      $2cflags_cc!$2: [ $2-fno-exceptions$2 ],\n      $2defines$2: [ $2NAPI_DISABLE_CPP_EXCEPTIONS$2 ],\n      $2conditions$2: [\n        [\'OS=="win"\', { $2defines$2: [ $2_HAS_EXCEPTIONS=1$2 ] }]\n      ]']
    ]
  };
}

const SourceFileOperations = [
  [/Nan::SetMethod\(target,[\s]*"(.*)"[\s]*,[\s]*([^)]+)\)/g, 'exports.Set(Napi::String::New(env, "$1"), Napi::Function::New(env, $2))'],

  [/v8::Local<v8::FunctionTemplate>\s+(\w+)\s*=\s*Nan::New<FunctionTemplate>\([\w\d:]+\);(?:\w+->Reset\(\1\))?\s+\1->SetClassName\(Nan::String::New\("(\w+)"\)\);/g, 'Napi::Function $1 = DefineClass(env, "$2", {'],
  [/Local<FunctionTemplate>\s+(\w+)\s*=\s*Nan::New<FunctionTemplate>\([\w\d:]+\);\s+(\w+)\.Reset\((\1)\);\s+\1->SetClassName\((Nan::String::New|Nan::New<(v8::)*String>)\("(.+?)"\)\);/g, 'Napi::Function $1 = DefineClass(env, "$6", {'],
  [/Local<FunctionTemplate>\s+(\w+)\s*=\s*Nan::New<FunctionTemplate>\([\w\d:]+\);(?:\w+->Reset\(\1\))?\s+\1->SetClassName\(Nan::String::New\("(\w+)"\)\);/g, 'Napi::Function $1 = DefineClass(env, "$2", {'],
  [/Nan::New<v8::FunctionTemplate>\(([\w\d:]+)\)->GetFunction\(\)/g, 'Napi::Function::New(env, $1)'],
  [/Nan::New<FunctionTemplate>\(([\w\d:]+)\)->GetFunction()/g, 'Napi::Function::New(env, $1);'],
  [/Nan::New<v8::FunctionTemplate>\(([\w\d:]+)\)/g, 'Napi::Function::New(env, $1)'],
  [/Nan::New<FunctionTemplate>\(([\w\d:]+)\)/g, 'Napi::Function::New(env, $1)'],

  // FunctionTemplate to FunctionReference
  [/Nan::Persistent<(v8::)*FunctionTemplate>/g, 'Napi::FunctionReference'],
  [/Nan::Persistent<(v8::)*Function>/g, 'Napi::FunctionReference'],
  [/v8::Local<v8::FunctionTemplate>/g, 'Napi::FunctionReference'],
  [/Local<FunctionTemplate>/g, 'Napi::FunctionReference'],
  [/v8::FunctionTemplate/g, 'Napi::FunctionReference'],
  [/FunctionTemplate/g, 'Napi::FunctionReference'],

  [/([ ]*)Nan::SetPrototypeMethod\(\w+, "(\w+)", (\w+)\);/g, '$1InstanceMethod("$2", &$3),'],
  [/([ ]*)(?:\w+\.Reset\(\w+\);\s+)?\(target\)\.Set\("(\w+)",\s*Nan::GetFunction\((\w+)\)\);/gm,
    '});\n\n' +
    '$1constructor = Napi::Persistent($3);\n' +
    '$1constructor.SuppressDestruct();\n' +
    '$1target.Set("$2", $3);'],

  // TODO: Other attribute combinations
  [/static_cast<PropertyAttribute>\(ReadOnly\s*\|\s*DontDelete\)/gm,
    'static_cast<napi_property_attributes>(napi_enumerable | napi_configurable)'],

  [/([\w\d:<>]+?)::Cast\((.+?)\)/g, '$2.As<$1>()'],

  [/\*Nan::Utf8String\(([^)]+)\)/g, '$1->As<Napi::String>().Utf8Value().c_str()'],
  [/Nan::Utf8String +(\w+)\(([^)]+)\)/g, 'std::string $1 = $2.As<Napi::String>()'],
  [/Nan::Utf8String/g, 'std::string'],

  [/v8::String::Utf8Value (.+?)\((.+?)\)/g, 'Napi::String $1(env, $2)'],
  [/String::Utf8Value (.+?)\((.+?)\)/g, 'Napi::String $1(env, $2)'],
  [/\.length\(\)/g, '.Length()'],

  [/Nan::MakeCallback\(([^,]+),[\s\\]+([^,]+),/gm, '$2.MakeCallback($1,'],

  [/class\s+(\w+)\s*:\s*public\s+Nan::ObjectWrap/g, 'class $1 : public Napi::ObjectWrap<$1>'],
  [/(\w+)\(([^)]*)\)\s*:\s*Nan::ObjectWrap\(\)\s*(,)?/gm, '$1($2) : Napi::ObjectWrap<$1>()$3'],

  // HandleOKCallback to OnOK
  [/HandleOKCallback/g, 'OnOK'],
  // HandleErrorCallback to OnError
  [/HandleErrorCallback/g, 'OnError'],

  // ex. .As<Function>() to .As<Napi::Object>()
  [/\.As<v8::(Value|B